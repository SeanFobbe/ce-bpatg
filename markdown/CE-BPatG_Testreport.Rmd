---
title: "Testbericht Corpus der Entscheidungen des Bundespatentgerichts (CE-BPatG)"
author: Seán Fobbe
geometry: margin=3cm
papersize: a4
fontsize: 11pt
output:
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
    pandoc_args: --listings
    includes:
      in_header: Preamble_DE.tex
---



```{r, setup, include=FALSE}
knitr::opts_chunk$set(fig.path = file.path("..", "analysis/"),
                      dev = config$fig$format,
                      dpi = config$fig$dpi,
                      fig.align = config$fig$align)

```



# Ergebnisse laden


```{r}

tar_load(scope)
tar_load(dt.download.final)
tar_load(dt.bpatg)
tar_load(files.pdf)
tar_load(files.txt)
tar_load(variables)

```





# Vollständigkeit der Datenbank-Auswertung


## Genauen Such-Umfang berechnen

```{r}
    scope <- f.extend(scope$year,
                      scope$pagemax0)


    scope <- rbindlist(scope)

    setnames(scope,
             c("year",
               "page"))
```


## Locator einfügen

```{r}


scope[, loc := {
    loc <- paste0(year,
                  "-",
                  page)
    list(loc)
}]


dt.download.final[, loc := {
    loc <- paste0(year,
                  "-",
                  page)
    list(loc)
}]



```


## Theoretischer Fehlbetrag

```{r}
SOLL <- scope[,.N] * 15 
IST <- dt.download.final[,.N]

missing.N <- SOLL - IST

print(missing.N)

```


## Seiten mit weniger als 15 Entscheidungen anzeigen

```{r}
less15 <- dt.download.final[, .N,  keyby = "loc"][N < 15]

print(less15)
```


## Fehlbetrag durch Seiten mit weniger als 15 Entscheidungen

```{r}
less15.N <- (length(less15$N) * 15) - sum(less15$N)
print(less15.N)
```

## Tatsächlicher Fehlbetrag

 **Test:** Ist der Fehlbetrag vollständig durch Seiten mit weniger als 15 Entscheidungen zu erklären? Falls ja, weisen beide sub-Tests maximal ein Ergebnis von 0 oder ein negatives Ergebnis auf.


### Fehlbetrag der NICHT durch Seiten mit weniger als 15 Entscheidungen erklärbar ist

```{r}
print(missing.N - less15.N)
```


### Gegenüberstellung: Anzahl Jahre und Anzahl Seiten mit weniger als 15 Entscheidungen

Für jedes Jahr sollte es eine letzte Seite mit weniger als 15 Entscheidungen geben. Falls zufällig die letzte Seite exakt 15 Entscheidungen hat, wäre das Ergebnis negativ. Ein Ergebnis von 0 oder kleiner bedeutet, dass der Test bestanden wurde. Der Test ist nur aussagekräftig wenn der gesamte Such-Umfang abgefragt wurde.

```{r}
if (config$debug$toggle == FALSE){
    less15[,.N] - uniqueN(scope$year)
    }
```


## Vorhandensein aller Jahr/Seiten-Kombinationen

Dieser Test zeigt an, ob alle Jahr/Seiten-Kombinationen auch in den Daten vorhanden sind. Falls nicht, zeigt er die fehlenden Kombinationen an.


```{r}
setdiff(scope$loc,
        dt.download.final$loc)
```




# Dateigrößen analysieren



## Datensatz in RAM (MB)

```{r}
print(object.size(dt.bpatg),
      standard = "SI",
      humanReadable = TRUE,
      units = "MB")
      
```


## CSV Korpus (MB)

```{r}
file.size(csvname.full) / 10 ^ 6
```

## CSV Metadaten (MB)

```{r}
file.size(csvname.meta) / 10 ^ 6
```



## PDF-Dateien (MB)

```{r}
pdf.MB <- file.size(files.pdf) / 10^6
sum(pdf.MB)
```


## TXT-Dateien (MB)


```{r}
txt.MB <- file.size(files.txt) / 10^6
sum(txt.MB)
```




\newpage
## Diagramm: Verteilung der Dateigrößen (PDF)



```{r, CE-BPatG_13_Density_Dateigroessen_PDF, fig.height = 6, fig.width = 9}

dt.plot <- data.table(pdf.MB)

ggplot(data = dt.plot,
       aes(x = pdf.MB)) +
    geom_density(fill = "#7e0731") +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x)))+
    annotation_logticks(sides = "b")+
    theme_bw() +
    labs(
        title = paste(prefix.figuretitle,
                      "| Verteilung der Dateigrößen (PDF)"),
        caption = caption,
        x = "Dateigröße in MB",
        y = "Dichte"
    )+
    theme(
        text = element_text(size = 14),
        plot.title = element_text(size = 14,
                                  face = "bold"),
        legend.position = "none",
        panel.spacing = unit(0.1, "lines"),
        plot.margin = margin(10, 20, 10, 10)
    )
    
```


\newpage
## Diagramm: Verteilung der Dateigrößen (TXT)



```{r, CE-BPatG_14_Density_Dateigroessen_TXT, fig.height = 6, fig.width = 9}

dt.plot <- data.table(txt.MB)

ggplot(data = dt.plot,
       aes(x = txt.MB)) +
    geom_density(fill = "#7e0731") +
    scale_x_log10(breaks = trans_breaks("log10", function(x) 10^x),
                  labels = trans_format("log10", math_format(10^.x)))+
    annotation_logticks(sides = "b")+
    theme_bw() +
    labs(
        title = paste(prefix.figuretitle,
                      "| Verteilung der Dateigrößen (TXT)"),
        caption = caption,
        x = "Dateigröße in MB",
        y = "Dichte"
    )+
    theme(
        text = element_text(size = 14),
        plot.title = element_text(size = 14,
                                  face = "bold"),
        legend.position = "none",
        panel.spacing = unit(0.1, "lines"),
        plot.margin = margin(10, 20, 10, 10)
    )

```




# Frequenztabellen erstellen


## Vorbereitung


```{r}

## Ignorierte Variablen
print(config$freqtable$ignore)



## Liste zu prüfender Variablen

varlist <- names(dt.bpatg)
varlist <- grep(paste(config$freqtable$ignore,
                      collapse = "|"),
                varlist,
                invert = TRUE,
                value = TRUE)
print(varlist)


## Präfix definieren

prefix <- paste0(config$project$shortname,
                 "_01_Frequenztabelle_var-")

```

## Frequenztabellen berechnen


```{r, results = "asis"}

f.fast.freqtable(dt.bpatg,
                 varlist = varlist,
                 sumrow = TRUE,
                 output.list = FALSE,
                 output.kable = TRUE,
                 output.csv = TRUE,
                 outputdir = dir.analysis,
                 prefix = prefix,
                 align = c("p{5cm}",
                           rep("r", 4)))

```
























# Parameter für strenge Replikationen


```{r}
system2("openssl", "version", stdout = TRUE)

sessionInfo()

```
